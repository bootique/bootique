<?xml version="1.0" encoding="UTF-8"?>
<part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0" xml:id="programming">
    <title>Programming</title>

    <chapter xml:id="programming-modules">
            <title>Modules</title>
            <para>Bootique apps are made of "modules". The framework simply locates all available
            modules, loads them in the DI environment, parses the command line, and then transfers
            control to a Command (that can originate from any of the modules) that matched the user
            choice. There's a growing list of modules created by Bootique development team. And you
            can easily write your own. In fact, programming in Bootique is primarily about writing
            Modules. </para>
            <para>A module is a Java library that contains some code. What makes it a module is a
            special Java class that implements <link
                xlink:href="https://google.github.io/guice/api-docs/latest/javadoc/index.html?com/google/inject/Module.html"
                >Guice Module interface</link>. This class defines what "services" or other types of
            objects the module provides (in other words what will be injectable by the module
            users). This is done in a form of "bindings", i.e. associations between publicly visible
            injectable service interfaces and specific
            implementations:<programlisting language="java">public class MyModule implements Module {
	@Override
	public void configure(Binder binder) {
		binder.bind(MyService.class).to(MyServiceImpl.class);
	}
}</programlisting></para>
            <para>There are other flavors of bindings in Guice. Please refer to <link
                xlink:href="https://github.com/google/guice/wiki/Motivation">Guice
                documentation</link> for details. One important form extensively used in Bootique is
                <link xlink:href="https://github.com/google/guice/wiki/Multibindings"
                >Multibinding</link>.</para>
        
    </chapter>
    <chapter xml:id="programming-module-providers">
            <title>Modules Auto-Loading</title>
            <para>Modules can be automatically loaded via <code>Bootique.autoLoadModules()</code> as
            long as they are included in your aplication dependencies. Auto-loading depends on the
            Java <link
                xlink:href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html"
                >ServiceLoader mechanism</link>. To ensure your modules can be auto-loaded do two
            things. First implement <code>com.nhl.bootique.BQModuleProvider</code> interface
            specific to your
            module:<programlisting language="java">public class MyModuleProvider implements BQModuleProvider {
	@Override
	public Module module() {
		return new MyModule();
	}
}</programlisting>After
            then create a file <code>META-INF/services/com.nhl.bootique.BQModuleProvider</code> with
            the only line being the name of your BQModuleProvider implementor. E.g.:</para>
            <programlisting>com.foo.MyModuleProvider</programlisting>
            <para><code>BQModuleProvider</code> has two more methods that you can optionally
            implement to help Bootique to make sense of the module being
            loaded:<programlisting language="java">public class MyModuleProvider implements BQModuleProvider {
	...
	// provides human-readable name of the module
	@Override
	public String name() {
		return "CustomName";
	}
	
	// a collection of modules whose services are overridden by this module
	@Override
	public Collection&lt;Class&lt;? extends Module>> overrides() {
		return Collections.singleton(BQCoreModule.class);
	}
}</programlisting></para>
        <para>If  in your Module you are planning to redefine any services from the upstream
            modules, specify those upstream modules in the <code>overrides()</code> collection. </para>
    </chapter>
    <chapter xml:id="programming-configuration">
            <title>Reading Configuration and Configurable Factories</title>
            <para>Usually a module exposes a single concern in your application, such as providing a
            DataSource to connect to the database, provide an embeddable web container, etc. This
            single concern is often represented as a single "service" class. Then the goal of module
            configuration becomes to create a factory based on configuration data, and then invoke
            this factory to create the service in question. Our configuration examples are based on
            this style. </para>
        <para>TODO</para>
        <section>
            <title>Polymorphic Configuration Objects</title>
            <para>TODO</para>
        </section>
    </chapter>
    <chapter xml:id="programming-using-modules">
            <title>Using Modules</title>
            <para>Modules can use other "upstream" modules in a few ways:<itemizedlist>
                <listitem>
                    <para>"Import": a downstream module uses another module as a library, ignoring
                        its injectable services.</para>
                </listitem>
                <listitem>
                    <para>"Use" : downstream module's classes inject classes from an upstream
                        module.</para>
                </listitem>
                <listitem>
                    <para>"Contribute": downstream module injects objects to collections and maps
                        defined in upstream modules.</para>
                </listitem>
            </itemizedlist></para>
            <para>Import case is trivial, so we'll concentrate on the two remaining scenarios. We
            will use <link
                xlink:href="https://github.com/nhl/bootique/blob/master/bootique/src/main/java/com/nhl/bootique/BQCoreModule.java"
                >BQCoreModule</link> as an example of an upstream module, as it is available in all
            apps.</para>
        <section>
            <title>Injecting Other Module's Services</title>
            <para>BQCoreModule provides a number of objects and services that can be accessed via
                injection and used by your code.
                E.g.:<programlisting language="java">class MyService {

	@Args
	@Inject
	private String[] args;

	public String getArgsString() {
		return Arrays.asList(getArgs()).stream().collect(joining(" "));
	}
}</programlisting></para>
            <para>In this example we injected command line arguments that were used to start the
                app. Note that since there can potentially be more than one <code>String[]</code> in
                a DI container, Bootique <code>@Args</code> annotation is used to uniquely identify
                the array that we want here.</para>
        </section>
        <section>
            <title>Contributing to Other Modules</title>
            <para>Guice supports <link
                    xlink:href="https://github.com/google/guice/wiki/Multibindings"
                    >multibindings</link>, intended to <emphasis>contribute</emphasis> objects
                defined in a downstream module to collections/maps used by services in upstream
                modules. E.g. the following code makes <code>MyCommand</code> available in the app
                set of
                commands:<programlisting>public class MyModule implements Module {

	@Override
	public void configure(Binder binder) {
		BQCoreModule.contributeCommands(binder)
			.addBinding()
			.to(MyCommand.class);
	}
}</programlisting></para>
            <para>Here we obtained a Multibinder instance via a static method on BQCoreModule. Most
                standard modules define such helper methods for every collection/map that should be
                populated by module users. This is a pattern you might want to follow in your own modules.<note>
                    <para>Commands can be alternatively contributed using a special
                            <code>Commands</code> module builder described below, which is a
                        shortcut for the code above.</para>
                </note></para>
        </section>
        </chapter>
    <chapter xml:id="programming-application-module">
            <title>Application as a Module</title>
            <para>The class that contains the <code>"main()"</code> method is informally called
                "application". Bootique does not impose any particular requirements on this class.
                You decide what to put in it. It can be limited to just <code>"main()"</code>,
                turned into a REST resource, etc. </para>
            <para>We recommend wrapping all your custom code in Guice modules. Then you can view
            your apps as collections of modules. In this scenario, it makes the most sense to write
            your application class as either just a launcher with the static <code>"main()"</code>
            method or in addition to that turn it into a Module as well. After all Bootique app is
            just a collection of Modules, and it is but logical that your Application represents
            that one final Module to rule them
            all:<programlisting>public class Application implements Module {

   public static void main(String[] args) {
      Bootique.app(args).module(Application.class).autoLoadModules().run();
   }

   public void configure(Binder binder) {
      // load app-specific services; redefine standard ones
   }
}</programlisting></para>
            <para>You may also implement a separate BQModuleProvider for the Application module.
            Then <code>autoLoadModules()</code> will discover it just like any other Module, and
            there won't be a need to add Application module explicitly.</para>
    </chapter>
        
    <chapter>
        <title>Commands and Options</title>
        <para>Bootique runtime contains a set of commands. Bootique derives a command name to
            execute from the command line arguments. The initial set of available commands is a
            combination of commands coming from Bootique core framework and any modules currently in
            effect in the app.</para>
        <para>TODO</para>
        
    </chapter>
 
    <chapter>
        <title>Logging</title>
        <para>TODO</para>
    </chapter>
</part>
